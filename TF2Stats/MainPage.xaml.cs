using Microsoft.Toolkit.Uwp.UI.Controls;
using StatsData;

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices.WindowsRuntime;
using Windows.Foundation;
using Windows.Foundation.Collections;
using Windows.UI.Xaml;
using Windows.UI.Xaml.Controls;
using Windows.UI.Xaml.Controls.Primitives;
using Windows.UI.Xaml.Data;
using Windows.UI.Xaml.Input;
using Windows.UI.Xaml.Media;
using Windows.UI.Xaml.Navigation;

// The Blank Page item template is documented at https://go.microsoft.com/fwlink/?LinkId=402352&clcid=0x409

namespace TF2Stats
{
    /// <summary>
    /// An empty page that can be used on its own or navigated to within a Frame.
    /// </summary>
    public sealed partial class MainPage : Page
    {
        public MainPage()
        {
            this.InitializeComponent();
            DataContext = new TF2CasualMode();
        }

        private void WeaponGrid_Sorting(object sender, DataGridColumnEventArgs e)
        {
            GenericGrid_Sorting<WeaponVM>((DataGrid)sender, e);
        }

        private void GenericGrid_Sorting<T>(DataGrid dg, DataGridColumnEventArgs e)
        {
            DataGridColumn sortColumn = e.Column;
            bool wasAscending = (sortColumn.SortDirection ?? DataGridSortDirection.Descending) == DataGridSortDirection.Ascending;
            IEnumerable<T> items = (IEnumerable<T>)dg.ItemsSource;

            string propertyName = GetPropertyName(sortColumn);

            //IEnumerable<T> sortedItems = GetSortedItems(isAscending, propertyName, items);
            System.Reflection.PropertyInfo propInfo = typeof(T).GetProperty(propertyName);
            Func<T, object> keySelector = (x) => propInfo.GetValue(x);
            IEnumerable<T> sortedItems = wasAscending
                ? items.OrderByDescending(keySelector)
                : items.OrderBy(keySelector);

            // Replace ItemsSource content using the items in sorted order.
            // TODO there's probably a better way to do this, but this works and it's faster than the autogenerated columns rebuild of the grid by setting ItemsSource.
            foreach (T item in sortedItems)
            {
                (dg.ItemsSource as ObservableCollection<T>).Remove(item);
                (dg.ItemsSource as ObservableCollection<T>).Add(item);
            }
            // Microsoft sample code says to do this, but this rebuilds the AutoGenerateColumns grid - very slow and forgets all Column information until later, so we can't set details of columns
            //dg.ItemsSource = new ObservableCollection<T>(sortedItems);

            // Update SortDirections
            foreach (DataGridColumn dgColumn in dg.Columns)
            {
                // can't directly compare column instances
                string colName = GetPropertyName(dgColumn);
                string sortName = GetPropertyName(sortColumn);
                if (!colName.Equals(sortName))
                {
                    dgColumn.SortDirection = null;
                }
                else
                {
                    dgColumn.SortDirection = wasAscending
                        ? DataGridSortDirection.Descending
                        : DataGridSortDirection.Ascending;
                }
            }
        }

        private static string GetPropertyName(DataGridColumn sortColumn)
        {
            return sortColumn.Tag?.ToString()
                ?? sortColumn.Header.ToString();
        }

        private void WeaponGrid_AutoGeneratingColumn(object sender, DataGridAutoGeneratingColumnEventArgs e)
        {
            string[] SkipColumns = new string[] { 
                "Alts",
                "Detail",
                "Ammo",
                "LoadoutStats",
            };
            if (SkipColumns.Contains((string)e.Column.Header))
            {
                e.Cancel = true;
            }
        }
    }
}
